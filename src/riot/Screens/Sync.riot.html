<Sync>
    <div class="sync">
        <TopMenu extrastyleclasses="with-swoop">
            <h3>{ TRANSLATIONS.latest() }</h3>
            <div class="filter-copy-container">
                <a class="btn btn-primary" onclick="{syncMe}">Sync Me</a>
            </div>
        </TopMenu>        

        <div class="content-wrapper">
            <ol class="sync-list">
                <li
                    each="{(statusListing, index) in state.statusListings}">
                    <div class="sync-header">
                        <h5>ID:${statusListing.id} ${statusListing.type}:${statusListing.title} Version:${statusListing.version}</h5>
                    </div>

                    <div class="sync-body">
                        <span>Version:${statusListing.version}</span>
                    </div>

                    <div
                        class="sync-body"
                        if="{statusListing.storeStatus !== 'unset' || statusListing.cacheStatus !== 'unset'}"
                    >
                        <span>Store URL:{ statusListing.api_url }, status:{ statusListing.storeStatus }</span>
                    </div>

                    <div
                        class="sync-body"
                        if="{statusListing.storeStatus !== 'unset' || statusListing.cacheStatus !== 'unset'}"
                    >
                        <span>Cache Key:{ statusListing.cacheKey }, status:{ statusListing.cacheStatus }</span>
                    </div>

                    <div
                        class="sync-body"
                        if="{statusListing.storeStatus !== 'unset' || statusListing.cacheStatus !== 'unset'}"
                    >
                        <span>Validity:{ statusListing.isValid },  </span>
                        <span>Availablity:{ statusListing.isAvailableOffline },  </span>
                        <span>Publishable:{ statusListing.isPublishable }, </span>
                    </div>

                    <!-- <div class="sync-footer">
                        <a class="action">
                            <span class="arrow-blue"></span>
                            <p>{ TRANSLATIONS.start() }</p>
                        </a>
                        <div>
                            <p>{showTimeAgoFromNow(sync.timestamp)}</p>
                        </div>
                    </div> -->
                </li>
            </ol>
        </div>
    </div>

    <script>
        import { AppDataStatus } from "ts/AppDataStatus";
        import { AppelflapConnect } from "ts/AppelflapConnect";
        // import { CacheUtilities } from "ts/CacheUtilities";
        import { CachePublish } from "ts/CachePublish";
        import { Manifest } from "ts/Implementations/Manifest";

        export default {
            state: {
                statusListings: [],
                cacheStatus: "",
                publications: "",
                manifest: "",
                page: "",
            },

            TRANSLATIONS: {
                latest: () => gettext("Latest syncs"),
                start: () => gettext("Start lesson"),
            },

            async onMounted() {
                await this.appelflapStatus();
            },

            async appelflapStatus() {
                this.update({ appelflapMeta: "Getting" });
                
                const appelflapConnect = new AppelflapConnect();
                const metaStatus = await appelflapConnect.getMetaStatus();
                this.update({ appelflapMeta: JSON.stringify(metaStatus) });

                /* Not yet implemented
                const cacheUtilities = new CacheUtilities(appelflapConnect);
                const cacheStatus = await cacheUtilities.status();
                this.update({ cacheStatus: JSON.stringify(cacheStatus) });
                */

                const cachePublish = new CachePublish(appelflapConnect);
                const publications = await cachePublish.publications();
                this.update(({ publications: JSON.stringify(publications) }));

                // Get the Item Status Listing
                const appDataStatus = new AppDataStatus();
                await appDataStatus.Initialise();
                await appDataStatus.BuildList();
                this.update({statusListings: appDataStatus.itemListings});

                // try to get the manifest
                // const manifest = new Manifest();
                // if (!manifest.isValid) {
                //     await manifest.initialiseByRequest();
                // }
                // if (manifest.isValid) {
                //     const data = JSON.stringify(manifest.data);
                //     this.update({ manifest: "Got a manifest" });

                //     // try getting a page
                //     const aPage = await manifest.getPageManifestData(
                //         "/site/resources/resource"
                //     );
                //     await aPage.initialiseByRequest();
                //     const manifestAssetCount = aPage.manifestAssets.length;
                //     const assetCount = aPage.assets.length;
                //     const pageData =
                //         `Page:${aPage.title} at ${aPage.loc_hash} ` +
                //         `Assets Defined:${manifestAssetCount} ` +
                //         `Assets Found:${assetCount} ` +
                //         `Valid:${aPage.isValid} ` +
                //         `Publishable:${aPage.isPublishable} ` +
                //         `Available Offline:${aPage.isAvailableOffline} ` +
                //         `Status:${aPage.status} `;
                //     this.update({ page: pageData });
                //     if (assetCount) {
                //         aPage.assets.forEach((asset) => {
                //             if (asset.isValid) {
                //                 this.update({ img: asset.fullUrl });
                //             }
                //         });
                //     }

                //     // try publishing the page
                //     aPage.publish(appelflapConnect);
                // }
            },

            syncMe() {
                // Identify what needs to be subscribed to, and what needs to be published
            },
        };
    </script>
</Sync>
