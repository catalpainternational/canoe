<Sync>
    <div class="sync">
        <TopMenu extrastyleclasses="without-swoop">
            <a class="top-icon left has-circle" href="#settings">
                <span class="arrow"></span>
            </a>
            <h4>{ TRANSLATIONS.syncTitle() }</h4>
        </TopMenu>

        <div class="content-wrapper">
            <div class="group">
                <h2>{ TRANSLATIONS.status() }</h2>

                <div class="sync-status">
                    <div>
                        <h4>{ syncStatusText }</h4>
                        <!-- TODO Get this date from the Manifest -->
                        <p>{ new Date().toDateString() }</p>
                    </div>
                    <div if="{state.syncStatus === 'updated'}" class="download-state complete">
                        <span class="icon"></span>
                    </div>
                </div>
            </div>

            <div class="group">
                <h2>{ TRANSLATIONS.avatar() }</h2>

                <p class="avatar {yourSyncAvatar.color}">
                    {yourSyncAvatar.color}<br>
                    {yourSyncAvatar.animal}<br>
                    {yourSyncAvatar.plant}
                </p>
            </div>

            <div if="{mappedPeers}" class="group">
                <h2>{ TRANSLATIONS.peers() }</h2>

                <div class="peers">
                    <p each="{peer in mappedPeers}" class="avatar {peer.color}">
                        {peer.color}<br>
                        {peer.animal}<br>
                        {peer.plant}
                    </p>
                </div>
            </div>

            <div class="group">
                <h2>{ TRANSLATIONS.wifi() }</h2>

                <div class="wifi-panel">
                    <div>
                        <template if="{connection.type === 'wifi'}">
                            <h4>{ TRANSLATIONS.connected() }</h4>
                            <p>
                                <template if="{connection.networkName}">
                                    <span><span class="wifi-icon"></span> { connection.networkName }</span>
                                    <span>&middot;</span>
                                </template>
                                <a onclick="{launchWiFiPicker}"><span class="settings-icon"></span> { TRANSLATIONS.settings() }</a>
                            </p>

                        </template>

                        <template if="{connection.type !== 'wifi'}">
                            <h4>{ TRANSLATIONS.notConnected() }</h4>
                            <p>
                                <a onclick="{launchWiFiPicker}"><span class="wifi-icon active"></span> { TRANSLATIONS.connect() }</a>
                            </p>
                        </template>
                    </div>
                    <div if="{connection.type === 'wifi'}" class="connected">
                        <span class="icon"></span>
                    </div>
                    <span if="{connection.type !== 'wifi'}" class="incorrect-cross"></span>
                </div>
            </div>

            <div class="group storage-panel">
                <h2>{ TRANSLATIONS.storage() }</h2>
                <div if="{usedSpacePercentage}" class="percentage-bar-container">
                    <div class="percentage-bar {usedSpacePercentageColor}"
                        style="width: {usedSpacePercentage}%">
                    </div>
                </div>
                <p>
                    <template if="{usedSpacePercentage}">
                        <span>{usedSpacePercentage}% { TRANSLATIONS.full() }</span>
                        <span>&middot;</span>
                    </template>
                    <a onclick="{launchStorageManager}">{ TRANSLATIONS.launchStorageManager() }</a>
                </p>
            </div>

            <!-- TODO I think this list can be removed - it's no longer in the design -->
            <ol class="sync-list">
                <li
                    each="{(statusListing, index) in state.statusListings}">
                    <div class="sync-header">
                        <h5><small>{statusListing.type}:</small> { statusListing.title }</h5>
                    </div>
                    <!-- <div class="sync-body"><small>version: {statusListing.version}</small></div> -->
                    <!-- <div if="{statusListing.backendPath === statusListing.cacheKey}" class="sync-body">
                        <span><small>Store Path/Cache Key:</small> { statusListing.backendPath }</span>
                    </div> -->
                    <!-- <div if="{statusListing.backendPath != statusListing.cacheKey}" class="sync-body">
                        <span><small>Store Path:</small> { statusListing.backendPath }</span>
                    </div> -->
                    <!-- <div if="{statusListing.backendPath != statusListing.cacheKey}" class="sync-body">
                        <span><small>Cache Key:</small> { statusListing.cacheKey }</span>
                    </div> -->

                    <div class="sync-body">
                        <span><small>Publishable:</small> { statusListing.isPublishable }, </span>
                    </div>

                    <!-- <div class="sync-footer">
                        <a class="action">
                            <span class="arrow-blue"></span>
                            <p>{ TRANSLATIONS.start() }</p>
                        </a>
                        <div>
                            <p>{showTimeAgoFromNow(sync.timestamp)}</p>
                        </div>
                    </div> -->
                </li>
            </ol>
        </div>
    </div>

    <script>
        import { AppDataStatus } from "ts/AppDataStatus";
        import { CacheUtilities } from "ts/Appelflap/CacheUtilities";
        import { CacheSubscribe } from "ts/Appelflap/CacheSubscribe";
        import { hashString } from "js/utilities";

        import TopMenu from "riot/Components/TopMenu.riot.html";

        export default {
            state: {
                statusListings: [],
                appDataStatus: new AppDataStatus(),
                // mocked data below
                deviceId: 1234567,
                peers: [1234589, 1234897, 1238967, 1289567, 1894567, "weft", "Q7ge", "jP52"],
                // could be "outdated" or "current" - determined from the Manifest
                contentStatus: "outdated",
                // We will know if 'content' (cache bandles) are outdated from what the Manifest tells us
                // We will not know whether updates are available for them (totally depends on our peers sharing stuff)
                // We will know whether everything that has been shared by others has been loaded in to our caches
                // could be "syncOff", "syncOn" (in progress), "syncCompleted",
                // "syncNotRelevant" (no more injectables), "syncSubscriptionError"
                syncStatus: "syncOff",
            },

            components: {
                topmenu: TopMenu,
            },

            TRANSLATIONS: {
                start: () => gettext("Start lesson"),
                syncTitle: () => gettext("Offline sync"),
                status: () => gettext("Sync status"),
                // It's not 'files' that are outdated, it's 'content'
                contentOutdated: () => gettext("Some of your content is outdated"),
                contentCurrent: () => gettext("You're all up to date"),
                syncOff: () => gettext("Waiting to start syncing"),
                syncOn: () => gettext("Getting updated content now"),
                syncCompleted: () => gettext("Content updated"), // There is no gaurantee that the user is 'all' up to date
                syncNotRelevant: () => gettext("You have the latest version of available content"),
                syncSubscriptionError: () => gettext("Subscribing to receive updated content failed"),
                refresh: () => gettext("Refresh"),
                avatar: () => gettext("Your sync avatar"),
                peers: () => gettext("Recently seen peers"),
                wifi: () => gettext("Your Wi-Fi network"),
                connected: () => gettext("You're connected to Wi-Fi"),
                notConnected: () => gettext("You're not connected to Wi-Fi"),
                settings: () => gettext("Settings"),
                connect: () => gettext("Connect to wi-fi"),
                storage: () => gettext("Manage storage"),
                full: () => gettext("Full"),
                launchStorageManager: () => gettext("Free up space"),
            },

            mapAvatar(id) {
                // TODO we'll probably need to translate these (but the colors for classes need to remain in English)
                const colors = ['pink','red','orange','yellow','teal','blue','purple'];
                const animals = ['bird','monkey','fish','dog','seal','shrimp','whale','dolphin',
                    'starfish','urchin','shark','porpoise','sloth','python','frog'];
                const plants = ['tree','grass','weed','sedge','shrub','rush','fern','coral',
                    'acorn','moss','nettle','flower'];

                const idHash = hashString("" + id);

                return {
                    id,
                    color: colors[idHash % colors.length],
                    animal: animals[idHash % animals.length],
                    plant: plants[idHash % plants.length],
                }
            },

            get yourSyncAvatar() {
                // TODO actual device id
                return this.mapAvatar(this.state.deviceId);
            },

            get syncStatusText() {
                return this.TRANSLATIONS[this.state.syncStatus]();
            },

            get mappedPeers() {
                // TODO the actual peers
                const peers = this.state.peers;
                return peers.map((it) => this.mapAvatar(it));
            },

            get usedSpacePercentage() {
                // TODO the percentage of device storage used
                return 30;
            },

            get usedSpacePercentageColor() {
                if (this.usedSpacePercentage <= 50) {
                    return "";
                } else if (this.usedSpacePercentage <= 90) {
                    return "orange";
                }
                return "red";
            },

            get connection() {
                return {
                    // TODO this API is only available on android and chrome OS, so I couldn't test it
                    // https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/type
                    type: NetworkInformation.type,
                    // TODO I'm not sure if we can get the network name?
                    networkName: undefined,
                }
            },

            /**
             * Perform the 'inbound' synchronisation of everything made available by other peers
             */
            performInboundSync() {
                this.update({syncStatus: "syncOn"});
                // CacheUtilities.injectAll().then(() => {
                //     this.update({syncStatus: "syncCompleted"});
                // });
            },

            onBeforeMount() {
                this.state.syncStatus = "syncOff";
            },

            async onMounted() {
                const subscriptionsUpdated = await this.refreshSubscriptions();
                await this.publishAll();
                if (subscriptionsUpdated) {
                    CacheSubscribe.injectables().then(async (bundles) => {
                        if (bundles.bundles.length > 0) {
                            await CacheUtilities.unlock();
                            this.performInboundSync();
                        } else {
                            this.update({syncStatus: "syncNotRelevant"});
                        }
                    });
                }
                await this.appelflapStatus();
            },

            async onUnmounted() {
                await CacheUtilities.lock();
            },

            async appelflapStatus() {
                this.update({ appelflapMeta: "Getting" });

                // Get the Item Status Listing
                await this.state.appDataStatus.BuildList();
                this.update({statusListings: this.state.appDataStatus.itemListings});
            },

            async refreshSubscriptions() {
                const appDataStatus = this.state.appDataStatus;
                const subscriptions = await appDataStatus.SetSubscriptions();
                if (JSON.stringify(subscriptions) === JSON.stringify({ types: { CACHE: { groups: {} } } })) {
                    // No subscriptions, several possible causes
                    this.update({syncStatus: "syncSubscriptionError"});
                    return false;
                }

                return true;
            },

            async publishAll() {
                const appDataStatus = this.state.appDataStatus;
                const published = await appDataStatus.PublishAll();
            },

            async launchWiFiPicker() {
                const result = await CacheUtilities.launchWiFiPicker();
            },

            async launchStorageManager() {
                const result = await CacheUtilities.launchStorageManager();
            },
        };
    </script>
</Sync>
