<Sync>
    <div class="sync">
        <TopMenu extrastyleclasses="without-swoop">
            <a class="top-icon left has-circle" href="#settings">
                <span class="arrow"></span>
            </a>
            <h4>{ TRANSLATIONS.sync() }</h4>
        </TopMenu>

        <div class="content-wrapper">
            <div class="group">
                <h2>{ TRANSLATIONS.status() }</h2>

                <div class="sync-status">
                    <div>
                        <h4 if="{state.syncStatus === 'outdated'}">{ TRANSLATIONS.foundNew() }</h4>
                        <h4 if="{state.syncStatus === 'syncing'}">{ TRANSLATIONS.syncing() }</h4>
                        <h4 if="{state.syncStatus === 'updated'}">{ TRANSLATIONS.current() }</h4>
                        <!-- TODO I don't know where we get this date -->
                        <p>{ new Date().toDateString() }</p>
                    </div>
                    <div if="{state.syncStatus === 'outdated' || state.syncStatus === 'syncing'}"
                        class="download-state {state.syncStatus === 'syncing' ? 'loading' : ''}"
                        onclick="{syncMe}">
                            <span class="download"></span>
                    </div>
                    <div if="{state.syncStatus === 'updated'}" class="download-state complete">
                        <span class="icon"></span>
                    </div>
                </div>
            </div>

            <div class="group">
                <h2>{ TRANSLATIONS.avatar() }</h2>

                <p class="avatar {yourSyncAvatar.color}">
                    {yourSyncAvatar.color}<br>
                    {yourSyncAvatar.animal}<br>
                    {yourSyncAvatar.plant}
                </p>
            </div>

            <div if="{mappedPeers}" class="group">
                <h2>{ TRANSLATIONS.peers() }</h2>

                <div class="peers">
                    <p each="{peer in mappedPeers}" class="avatar {peer.color}">
                        {peer.color}<br>
                        {peer.animal}<br>
                        {peer.plant}
                    </p>
                </div>
            </div>

            <div class="group">
                <h2>{ TRANSLATIONS.wifi() }</h2>

                <div class="wifi-panel">
                    <div>
                        <template if="{connection.type === 'wifi'}">
                            <h4>{ TRANSLATIONS.connected() }</h4>
                            <p>
                                <template if="{connection.networkName}">
                                    <span><span class="wifi-icon"></span> { connection.networkName }</span>
                                    <span>&middot;</span>
                                </template>
                                <a onclick="{launchWiFiPicker}"><span class="settings-icon"></span> { TRANSLATIONS.settings() }</a>
                            </p>

                        </template>

                        <template if="{connection.type !== 'wifi'}">
                            <h4>{ TRANSLATIONS.notConnected() }</h4>
                            <p>
                                <a onclick="{launchWiFiPicker}"><span class="wifi-icon active"></span> { TRANSLATIONS.connect() }</a>
                            </p>
                        </template>
                    </div>
                    <div if="{connection.type === 'wifi'}" class="connected">
                        <span class="icon"></span>
                    </div>
                    <span if="{connection.type !== 'wifi'}" class="incorrect-cross"></span>
                </div>
            </div>

            <div class="group storage-panel">
                <h2>{ TRANSLATIONS.storage() }</h2>
                <div if="{usedSpacePercentage}" class="percentage-bar-container">
                    <div class="percentage-bar {usedSpacePercentage > 50 && usedSpacePercentage <= 90 ? 'orange' : ''} {usedSpacePercentage > 90 ? 'red' : ''}"
                        style="width: {usedSpacePercentage}%">
                    </div>
                </div>
                <p>
                    <template if="{usedSpacePercentage}">
                        <span>{usedSpacePercentage}% { TRANSLATIONS.full() }</span>
                        <span>&middot;</span>
                    </template>
                    <a onclick="{launchStorageManager}">{ TRANSLATIONS.launchStorageManager() }</a>
                </p>
            </div>

            <!-- TODO I think this list can be removed - it's no longer in the design -->
            <ol class="sync-list">
                <li
                    each="{(statusListing, index) in state.statusListings}">
                    <div class="sync-header">
                        <h5><small>{statusListing.type}:</small> { statusListing.title }</h5>
                    </div>
                    <!-- <div class="sync-body"><small>version: {statusListing.version}</small></div> -->
                    <!-- <div if="{statusListing.backendPath === statusListing.cacheKey}" class="sync-body">
                        <span><small>Store Path/Cache Key:</small> { statusListing.backendPath }</span>
                    </div> -->
                    <!-- <div if="{statusListing.backendPath != statusListing.cacheKey}" class="sync-body">
                        <span><small>Store Path:</small> { statusListing.backendPath }</span>
                    </div> -->
                    <!-- <div if="{statusListing.backendPath != statusListing.cacheKey}" class="sync-body">
                        <span><small>Cache Key:</small> { statusListing.cacheKey }</span>
                    </div> -->

                    <div class="sync-body">
                        <span><small>Publishable:</small> { statusListing.isPublishable }, </span>
                    </div>

                    <!-- <div class="sync-footer">
                        <a class="action">
                            <span class="arrow-blue"></span>
                            <p>{ TRANSLATIONS.start() }</p>
                        </a>
                        <div>
                            <p>{showTimeAgoFromNow(sync.timestamp)}</p>
                        </div>
                    </div> -->
                </li>
            </ol>
        </div>
    </div>

    <script>
        import { AppDataStatus } from "ts/AppDataStatus";
        import { CacheUtilities } from "ts/Appelflap/CacheUtilities";
        import { CachePublish } from "ts/Appelflap/CachePublish";
        import { hashString } from "js/utilities";

        import TopMenu from "riot/Components/TopMenu.riot.html";

        export default {
            state: {
                statusListings: [],
                publications: "",
                appDataStatus: new AppDataStatus(),
                // mocked data below
                deviceId: '2198734892374',
                peers: ['123456789','328947230','213897472','890374185','5','dsa-r34jkl','1asbd','2dhdflgiam'],
                // could be 'outdated', 'syncing', 'updated' (defines the text & loading animation logic)
                syncStatus: 'outdated',
            },

            components: {
                topmenu: TopMenu,
            },

            TRANSLATIONS: {
                start: () => gettext("Start lesson"),
                sync: () => gettext("Offline sync"),
                status: () => gettext("Sync status"),
                foundNew: () => gettext("We've found new files"),
                syncing: () => gettext("Syncing files now"),
                current: () => gettext("You're all up to date"),
                refresh: () => gettext("Refresh"),
                avatar: () => gettext("Your sync avatar"),
                peers: () => gettext("Recently seen peers"),
                wifi: () => gettext("Your Wi-Fi network"),
                connected: () => gettext("You're connected to Wi-Fi"),
                notConnected: () => gettext("You're not connected to Wi-Fi"),
                settings: () => gettext("Settings"),
                connect: () => gettext("Connect to wi-fi"),
                storage: () => gettext("Manage storage"),
                full: () => gettext("Full"),
                launchStorageManager: () => gettext("Free up space"),
            },

            mapAvatar(id) {
                // TODO we'll probably need to translate these (but the colors for classes need to remain in English)
                const colors = ['pink','red','orange','yellow','teal','blue','purple'];
                const animals = ['bird','monkey','fish','dog','seal','shrimp','whale','dolphin',
                    'starfish','urchin','shark','porpoise','sloth','python','frog'];
                const plants = ['tree','grass','weed','sedge','shrub','rush','fern','coral',
                    'acorn','moss','nettle','flower'];

                const idHash = hashString(id);

                return {
                    id,
                    color: colors[idHash % colors.length],
                    animal: animals[idHash % animals.length],
                    plant: plants[idHash % plants.length],
                }
            },

            get yourSyncAvatar() {
                // TODO actual device id
                return this.mapAvatar(this.state.deviceId);
            },

            get mappedPeers() {
                // TODO the actual peers
                const peers = this.state.peers;
                return peers.map((it) => this.mapAvatar(it));
            },

            get usedSpacePercentage() {
                // TODO the percentage of device storage used
                return '30';
            },

            get connection() {
                return {
                    // TODO this API is only available on android and chrome OS, so I couldn't test it
                    // https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/type
                    type: NetworkInformation.type,
                    // TODO I'm not sure if we can get the network name?
                    networkName: undefined,
                }
            },

            async onMounted() {
                await CacheUtilities.unlock();
                await this.appelflapStatus();
            },

            async onUnmounted() {
                await CacheUtilities.lock();
            },

            async appelflapStatus() {
                this.update({ appelflapMeta: "Getting" });

                const publications = await CachePublish.publications();
                this.update(({ publications: JSON.stringify(publications) }));
                // window.alert(`Published: ${JSON.stringify(publications)}`);

                // Get the Item Status Listing
                await this.state.appDataStatus.BuildList();
                this.update({statusListings: this.state.appDataStatus.itemListings});
            },

            async syncMe() {
                this.update({syncStatus: 'syncing'})
                // setTimeout(() => {
                //     // TODO this timeout is for testing / visualising in not-android. delete.
                //     this.update({syncStatus: 'updated'})
                // }, 3000)

                // Identify what needs to be subscribed to, and what needs to be published
                const appDataStatus = this.state.appDataStatus;
                const syncStatus = await appDataStatus.SyncAll();

                // window.alert(`Published: ${JSON.stringify(syncStatus)}`);
                this.update({syncStatus: 'updated'})
            },

            async launchWiFiPicker() {
                const result = await CacheUtilities.launchWiFiPicker();
            },

            async launchStorageManager() {
                const result = await CacheUtilities.launchStorageManager();
            },
        };
    </script>
</Sync>
