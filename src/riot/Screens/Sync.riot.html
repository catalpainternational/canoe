<Sync>
    <div class="sync">
        <TopMenu extrastyleclasses="without-swoop">
            <a class="top-icon left has-circle" href="#settings">
                <span class="arrow"></span>
            </a>
            <h4>{ TRANSLATIONS.syncTitle() }</h4>
        </TopMenu>

        <div class="content-wrapper">
            <div class="group">
                <h2>{ TRANSLATIONS.status() }</h2>

                <div class="sync-status">
                    <div>
                        <h4>{ syncStatusText }</h4>
                        <p>{ TRANSLATIONS.lastUpdated() }: { lastUpdatedDate }</p>
                    </div>
                    <div class="status-icon {state.syncStatus}">
                        <span class="icon"></span>
                    </div>
                </div>
            </div>

            <div class="group">
                <h2>{ TRANSLATIONS.avatar() }</h2>

                <p class="avatar {yourSyncAvatar.color}">
                    {yourSyncAvatar.id}<br>
                </p>
            </div>

            <div if="{mappedPeers.length}" class="group">
                <h2>{ TRANSLATIONS.peers() }</h2>

                <div class="peers">
                    <p each="{peer in mappedPeers}" class="avatar {peer.color}">
                        {peer.id}
                    </p>
                </div>
            </div>

            <div class="group">
                <h2>{ TRANSLATIONS.wifi() }</h2>

                <div class="wifi-panel">
                    <div>
                        <template if="{connection.type === 'wifi'}">
                            <h4>{ TRANSLATIONS.connected() }</h4>
                            <p>
                                <template if="{connection.networkName}">
                                    <span><span class="wifi-icon"></span> { connection.networkName }</span>
                                    <span>&middot;</span>
                                </template>
                                <a onclick="{launchWiFiPicker}"><span class="settings-icon"></span> { TRANSLATIONS.settings() }</a>
                            </p>

                        </template>

                        <template if="{connection.type !== 'wifi'}">
                            <h4>{ TRANSLATIONS.notConnected() }</h4>
                            <p>
                                <a onclick="{launchWiFiPicker}"><span class="wifi-icon active"></span> { TRANSLATIONS.connect() }</a>
                            </p>
                        </template>
                    </div>
                    <div if="{connection.type === 'wifi'}" class="connected">
                        <span class="icon"></span>
                    </div>
                    <span if="{connection.type !== 'wifi'}" class="incorrect-cross"></span>
                </div>
            </div>

            <div class="group storage-panel">
                <h2>{ TRANSLATIONS.storage() }</h2>
                <div if="{usedSpacePercentage}" class="percentage-bar-container">
                    <div class="percentage-bar {usedSpacePercentageColor}"
                        style="width: {usedSpacePercentage}%">
                    </div>
                </div>
                <p>
                    <template if="{usedSpacePercentage}">
                        <span>{usedSpacePercentage}% { TRANSLATIONS.full() }</span>
                        <span>&middot;</span>
                    </template>
                    <a onclick="{launchStorageManager}">{ TRANSLATIONS.launchStorageManager() }</a>
                </p>
            </div>

            <!-- Status of each cached item -->
            <ol if="{state.isNotProduction}" class="sync-list" style="line-height: 1;">
                <li
                    each="{(statusListing, index) in state.statusListings}">
                    <div class="sync-header">
                        <h5 style="color:{statusListing.isPublishable ? 'green' : 'red'}; margin: 0.2em 0;">
                            <small style="color:black;">{statusListing.type}:</small> { statusListing.title }
                        </h5>
                    </div>
                    <!-- <div class="sync-body"><small>version: {statusListing.version}</small></div> -->
                </li>
            </ol>
        </div>
    </div>

    <script>
        import { SyncStatus } from "ts/SyncStatus";
        import { AppelflapUtilities } from "ts/Appelflap/AppelflapUtilities";
        import { CacheUtilities } from "ts/Appelflap/CacheUtilities";
        import { CacheSubscribe } from "ts/Appelflap/CacheSubscribe";
        import { AF_EMPTY_TAGGED_SUBSCRIPTIONS } from "ts/Constants";
        import { hashString } from "js/utilities";
        import { getRoute } from "ReduxImpl/Interface";

        import TopMenu from "riot/Components/TopMenu.riot.html";

        const peerPropDefault = { friendly_id: "unknown" };

        export default {
            state: {
                statusListings: [],
                ssid: "",
                peerId: peerPropDefault,
                peers: [],
                syncStatus: "Off",
                isNotProduction: process.env.NODE_ENV && process.env.NODE_ENV !== "production",
            },

            components: {
                topmenu: TopMenu,
            },

            TRANSLATIONS: {
                start: () => gettext("Start lesson"),
                syncTitle: () => gettext("Offline sync"),
                status: () => gettext("Sync status"),
                lastUpdated: () => gettext("Last updated"),

                // Sync Statuses
                Off: () => gettext("Not syncing"),
                Initialisation: () => gettext("Preparing to start syncing"),
                Syncing: () => gettext("Syncing in progress"),
                NoWiFi: () => gettext("Getting updated content needs WiFi"),
                NoPeers: () => gettext("Getting updated content needs Peers"),
                UpToDate: () => gettext("Content updated"),

                refresh: () => gettext("Refresh"),
                avatar: () => gettext("Your sync avatar"),
                peers: () => gettext("Recently seen peers"),
                wifi: () => gettext("Your Wi-Fi network"),
                connected: () => gettext("You're connected to Wi-Fi"),
                notConnected: () => gettext("You're not connected to Wi-Fi"),
                settings: () => gettext("Settings"),
                connect: () => gettext("Connect to wi-fi"),
                storage: () => gettext("Manage storage"),
                full: () => gettext("Full"),
                launchStorageManager: () => gettext("Free up space"),
            },

            get manifest() {
                return getRoute().page.manifest;
            },

            get lastUpdatedDate() {
                return new Date(this.manifest.version / 1000).toDateString();
            },

            mapAvatar(id) {
                const colors = ['pink','red','orange','yellow','teal','blue','purple'];

                const idHash = hashString("" + id);

                return {
                    id,
                    color: colors[idHash % colors.length],
                }
            },

            get yourSyncAvatar() {
                return this.mapAvatar(this.state.peerId.friendly_id);
            },

            get syncStatusText() {
                return this.TRANSLATIONS[this.state.syncStatus]();
            },

            get mappedPeers() {
                const peers = this.state.peers;
                return peers.map((peer) => this.mapAvatar(peer.friendly_id));
            },

            get usedSpacePercentage() {
                return Math.round(this.state.usedSpacePercentage || 0);
            },

            get usedSpacePercentageColor() {
                if (this.usedSpacePercentage <= 50) {
                    return "";
                } else if (this.usedSpacePercentage <= 90) {
                    return "orange";
                }
                return "red";
            },

            get connection() {
                return {
                    type: this.state.ssid ? "wifi" : "",
                    networkName: this.state.ssid || "",
                }
            },

            async onMounted() {
                // Fire up the SyncStatus
                SyncStatus.getInstance().On();
            },

            async onUnmounted() {
                // Shut SyncStatus down
                SyncStatus.getInstance().Off();

                // The cache should already be locked, but just in case someone did something weird
                await CacheUtilities.lock();
            },

            storeListener(previousStoreState, storeState) {
                if (previousStoreState.syncState !== storeState.syncState) {
                    console.log(JSON.stringify(previousStoreState.syncState));
                    console.log(JSON.stringify(storeState.syncState));
                    
                    // this.update({ 
                    //     toastMessage: storeState.online ? this.TRANSLATIONS.online() : this.TRANSLATIONS.offline(),
                    // });
                }
            },

            async launchWiFiPicker() {
                const result = await AppelflapUtilities.launchWiFiPicker();
            },

            async launchStorageManager() {
                const result = await AppelflapUtilities.launchStorageManager();
            },
        };
    </script>
</Sync>
