<DiscussionThread>
    <div class="card full-width">
        <div class="lesson-title">
            <span class="arrow" onclick="{() => props.selectDiscussionHandler(null)}"></span>
            <p class="number">{props.lessonNumber}</p>
            <p class="title">{props.lesson.title}</p>
        </div>
        <div class="discussion-header">
            <h2 class="no-clamp">{props.question.question}</h2>
        </div>
        <div id="comment-input" class="form-group">
            <label for="comment">{TRANSLATIONS.addComment()}</label>
            <textarea
                name="comment"
                id="comment"
                oninput="{updateCommentValue}"
                onfocus="{setInputFocus}"
                onblur="{removeInputFocus}"
                maxlength="280"
            ></textarea>
        </div>
        <button
            if="{state.commentButtonVisible}"
            class="btn-primary"
            onclick="{addComment}">
            {TRANSLATIONS.postComment()}
        </button>

        <div if="{!state.comments.length}">
            <LoadingDots if="{state.loading}"></LoadingDots>
            <p if="{state.loading}">Loading!</p>
            <p>TODO (need design): Be the first to contribute to the conversation! Add a comment above.</p>
        </div>

        <template if="{state.comments.length}">
            <div class="sort-options">
                <p class="label">{TRANSLATIONS.sort()}</p>
                <div class="dropdown">
                    <p class="active" onclick="{toggleSort}">
                        {state.activeSortOption.label}
                        <span class="caret" if="{state.showSortOptions}">&#9650;</span>
                        <span class="caret" if="{!state.showSortOptions}">&#9660;</span>
                    </p>
                    <div if="{state.showSortOptions}" class="option">
                        <p class="option" each="{option in state.sortOptions}" if="{option.label !== state.activeSortOption.label}" onclick="{() => sortComments(option)}">{option.label}</p>
                    </div>
                </div>
            </div>

            <DiscussionComment
                each="{comment in state.comments}"
                comment="{comment}"
                lesson="{props.lesson}"
                addReply="{addReply}"
                flagInappropriate="{flagInappropriate}"
                updateCommentValue="{updateCommentValue}"
                setInputFocus="{setInputFocus}"
                removeInputFocus="{removeInputFocus}"
            ></DiscussionComment>
        </template>


    </div>

    <div id="toast-message">
        <span if="{state.successfulToast}" class="checkmark"></span>
        <span if="{!state.successfulToast}" class="cross red"></span>
        <p>{state.toastMessage}</p>
    <div>

    <script>
        import DiscussionComment from "RiotTags/Components/DiscussionComment.riot.html";

        import { postComment, getDiscussionComments, flagComment } from "js/DiscussionUtilities";
        import { v4 as uuidv4 } from "uuid";

        function DiscussionThread() {
            return {
                state: {
                    commentButtonVisible: false,
                    loading: false,
                    comments: [],
                    sortOptions: [
                        { sort: 'date', order: 'desc', label: gettext('Newest First') },
                        { sort: 'date', order: 'asc', label: gettext('Oldest First') }
                    ],
                    activeSortOption: { sort: 'date_created', order: 'desc', label: 'Newest First' },
                    showSortOptions: false,
                    toastMessage: '',
                    successfulToast: true,
                },

                TRANSLATIONS: {
                    addComment: () => gettext("Add a comment"),
                    postComment: () => gettext("Post comment"),
                    sort: () => gettext("Sort by"),
                    commentConfirmed: () => gettext("Comment posted"),
                    inappropriate: () => gettext("Comment flagged as inappropriate"),
                    error: () => gettext("An error occurred, please try again later"),
                },

                onBeforeMount(props, state) {
                    this.updateComments();
                },


                updateComments() {
                    this.state.loading = true;

                    getDiscussionComments(this.props.question.id).then((response) => {
                        this.update({ comments: this.mapComments(response), loading: false });
                        console.log(this.state.comments, this.mapComments(response))
                    });
                },

                mapComments(comments) {
                    return comments.map((comment, index, array) => ({
                        ...comment,
                        initials: `${comment.user_first_name[0]}${comment.user_last_name[0]}`,
                        date: new Date(comment.date_created),
                        replies: array.filter((it) => it.parent_id === comment.id)
                            .map(it => ({
                                ...it,
                                initials: `${it.user_first_name[0]}${it.user_last_name[0]}`,
                            })),
                    }))
                    .filter((comment) => comment.parent_id === null);
                },

                toggleSort() {
                    this.update({showSortOptions: !this.state.showSortOptions})
                },

                sortComments(sortOption) {
                    const sortOptions = this.state.sortOptions;
                    const comments = this.state.comments;

                    if (sortOption.order === 'asc') {
                        comments.sort((a, b) => a[sortOption.sort] - b[sortOption.sort]);
                    }
                    else if (sortOption.order === 'desc') {
                        comments.sort((a, b) => b[sortOption.sort] - a[sortOption.sort]);
                    }

                    this.update({
                        comments,
                        activeSortOption: sortOption,
                        showSortOptions: false,
                    });
                },

                updateCommentValue() {
                    const commentInput = this.$("#comment");

                    if (commentInput.value.length) {
                        this.update({commentButtonVisible: true});
                    }
                    else this.update({commentButtonVisible: false});
                },

                setInputFocus(event) {
                    const fieldElement = `#${event.target.id}-input`;
                    this.$(fieldElement).classList.add("has-focus");
                },

                removeInputFocus(event) {
                    const fieldElement = `#${event.target.id}-input`;
                    const fieldHasValue = event.target.value != "";

                    this.$(fieldElement).classList.remove("has-focus");

                    if (fieldHasValue && !this.$(fieldElement).classList.contains("is-filled")) {
                        this.$(fieldElement).classList.add("is-filled");
                    } else if (!fieldHasValue) {
                        this.$(fieldElement).classList.remove("is-filled");
                    }
                },

                addComment() {
                    const commentInput = this.$('#comment');

                    const newComment = {
                        page_id: this.props.lesson.id,
                        discussion_id: this.props.question.id,
                        date_created: new Date().toISOString().replace('Z', '+00:00'),
                        comment: commentInput.value,
                        id: uuidv4(),
                        posting_type: 'C',
                    }

                    postComment(newComment).then((response) =>{
                        if (!response.ok) {
                            this.commentStatus(newComment.id, this.TRANSLATIONS.error(), false);
                            throw new Error(`Comment failed, HTTP status: ${response.status}`);
                        }
                        else {
                            commentInput.value = '';
                            this.updateComments();
                            this.commentStatus(newComment.id);
                        }
                    });
                },

                addReply(reply, input, closeCallback) {
                    const newReply = {
                        ...reply,
                        page_id: this.props.lesson.id,
                        discussion_id: this.props.question.id,
                    }

                    postComment(newReply).then((response) =>{
                        if (!response.ok) {
                            this.commentStatus(newReply.id, this.TRANSLATIONS.error(), false);
                            throw new Error(`Comment failed, HTTP status: ${response.status}`);
                        }
                        else {
                            this.updateComments();
                            input.value = '';
                            closeCallback();
                            this.commentStatus(newReply.id);
                        }
                    });
                },

                commentStatus(id, customMessage = this.TRANSLATIONS.commentConfirmed(), success = true) {
                    this.update({
                        toastMessage: customMessage,
                        successfulToast: success,
                    });


                    const toast = document.getElementById('toast-message');
                    toast.className = 'show';
                    setTimeout(function() {
                        toast.className = toast.className.replace('show', '');
                    }, 4000);

                    // debugger;
                    // TODO this ain't workin
                    const newCommentEl = document.getElementById(id);
                    newCommentEl.className = 'recent';
                    setTimeout(function () {
                        newCommentEl.className = '';
                    }, 6000)
                },

                flagInappropriate(comment) {
                    const flaggedComment = {
                        page_id: comment.page_id,
                        discussion_id: comment.discussion_id,
                        date_created: new Date().toISOString().replace('Z', '+00:00'),
                        flag_inappropriate: true,
                        id: uuidv4(),
                        posting_id: comment.id,
                    }

                    flagComment(flaggedComment).then((response) =>{
                        console.log(response);
                        if (!response.ok) {
                            this.commentStatus(flaggedComment.id, this.TRANSLATIONS.error(), false);
                            throw new Error(`Comment failed, HTTP status: ${response.status}`);
                        }
                        else {
                            this.commentStatus(flaggedComment.id, this.TRANSLATIONS.inappropriate());
                        }
                    });
                },
            };
        };

        DiscussionThread.components = {
            discussioncomment: DiscussionComment,
        };

        export default DiscussionThread;
    </script>
</DiscussionThread>
