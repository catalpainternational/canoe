<CourseExam>
    <LessonFrame if="{ state.stage === 'code' }" linkTo="{ course.loc_hash }">
        <HonorCode minimumScore="{ MINIMUM_SCORE }"></HonorCode>
    </LessonFrame>
    <LessonFrame
        if="{ state.card }"
        id="test"
        extraStyleClasses="test"
        linkTo="{ course.loc_hash }"
        progressValue="{ state.cardNumber }"
        progressMax="{ state.cards.length + 1 }"
    >
        <h3>{state.cardNumber }. {state.card.question}</h3>
        <TestSingleAnswer
            if="{state.card.type === SINGLE_CHOICE}"
            isCourseExam="{true}"
            card="{state.card}"
            recordAnswer="{recordAnswer}"
            savedAnswer="{state.currentAnswer.answers}"
        ></TestSingleAnswer>
        <TestMultipleAnswer
            if="{state.card.type !== SINGLE_CHOICE}"
            isCourseExam="{true}"
            card="{state.card}"
            recordAnswer="{recordAnswer}"
            savedAnswer="{state.currentAnswer.answers}"
        ></TestMultipleAnswer>
        <div class="bottom-buttons">
            <div>
                <a if="{state.cardNumber > 1}" class="has-circle" onclick="{previousExamCard}">
                    <span class="arrow"></span>
                </a>
            </div>
            <div>
                <button
                    if="{ state.cardNumber < state.cards.length }"
                    class="btn-primary"
                    onclick="{ nextExamCard }"
                    disabled="{Object.keys(state.currentAnswer).length === 0}"
                >
                    { TRANSLATIONS.next() }
                </button>
                <button
                    if="{ state.cardNumber === state.cards.length }"
                    class="btn-primary"
                    onclick="{ nextExamCard }"
                    disabled="{Object.keys(state.currentAnswer).length === 0}"
                >
                    { TRANSLATIONS.submit() }
                </button>
            </div>
        </div>
    </LessonFrame>
    <ExamResults
        if="{ state.stage === 'results' }"
        course="{ this.course }"
        title="{ this.course.title }"
        finalScore="{calculateFinalScore()}"
        minimumScore="{MINIMUM_SCORE}"
    ></ExamResults>

    <script>
        import ExamResults from "RiotTags/Lesson/ExamResults.riot.html";
        import TestSingleAnswer from "RiotTags/Lesson/TestSingleAnswer.riot.html";
        import TestMultipleAnswer from "RiotTags/Lesson/TestMultipleAnswer.riot.html";
        import LessonFrame from "RiotTags/Components/LessonFrame.riot.html";
        import HonorCode from "RiotTags/Lesson/HonorCode.riot.html";

        import { getRoute } from "ReduxImpl/Interface";

        import { dispatchTestAnswerEvent, ON_ANSWERED_TEST_QUESTION } from "js/Events";
        import { URLDoesntExist, ExamIsMissingAnAnswer } from "js/Errors";

        import ExamGrader from "js/ExamGrader";

        export default {
            state: {
                currentAnswer: {},
            },

            components: {
                examresults: ExamResults,
                testsingleanswer: TestSingleAnswer,
                testmultipleanswer: TestMultipleAnswer,
                lessonframe: LessonFrame,
                honorcode: HonorCode,
            },

            TRANSLATIONS: {
                next: () => gettext("Next"),
                submit: () => gettext("Submit answers"),
            },

            MINIMUM_SCORE: 75,
            SINGLE_CHOICE: "single_choice",
            SECTION: "exam",

            readState() {
                const route = getRoute()
                const stage = route.riotHash[1] || 'code';
                const cardNumber = parseInt(stage);
                this.state.cardNumber = cardNumber;
                this.state.stage = stage;
                if (this.state.cards === undefined && this.course.ready) {
                    this.state.cards = this.shuffleCards(this.course.examCards).slice(0, 5);
                }
                if (this.state.cards && this.state.cardNumber) {
                    this.state.card = this.state.cards[this.state.cardNumber - 1];
                }
            },

            onBeforeMount(props, state) {
                this.course = getRoute().page;
                this.readState();
            },

            onBeforeUpdate() {
                this.readState();
            },

            shuffleCards(cards) {
                return cards.slice().sort(() => Math.random() - 0.5);
            },

                /*
            onHashChange() {

                if (this.isAtHonorCode(cardIdx) || this.isAtResults(cardIdx)) {
                    return;
                }

                const card = this.getCard(cardIdx);
                const previousAnswer = ExamGrader.loadExamAnswer(card.id);
                const currentAnswer = previousAnswer || {};

                this.state.cardAnswers = card.answers;
                this.shuffleCards(this.state.cardAnswers);
                card.answers = this.state.cardAnswers;

                this.update({
                    card,
                    currentAnswer,
                });

                window.scroll(0, 0);
            },*/

            isAtHonorCode(cardIdx) {
                return cardIdx === -1;
            },

            isAtResults(cardIdx) {
                return cardIdx === this.state.cards.length;
            },

            recordAnswer(response) {
                console.assert(
                    response.hasOwnProperty("answers") && response.hasOwnProperty("isCorrect")
                );

                this.update({ currentAnswer: response });
            },

            previousExamCard() {
                location.hash = `${this.course.loc_hash}:exam:${this.state.cardNumber - 1}`;
            },

            nextExamCard() {
                const { cardIdx, card, currentAnswer } = this.state;
                ExamGrader.saveExamAnswer(card.id, currentAnswer);
                location.hash = `${this.course.loc_hash}:exam:${this.state.cardNumber + 1}`;
                //location.hash = getNextCardsUrl(wagtailPage.id, this.SECTION, cardIdx);
            },

            calculateFinalScore() {
                const { cards } = this.props;
                const listOfExamQuestions = cards.map(card => card.id);
                try {
                    return Math.round(ExamGrader.tallyFinalScore(listOfExamQuestions));
                } catch (err) {
                    if (err instanceof ExamIsMissingAnAnswer) {
                        return 0;
                    }
                    throw err;
                }
            },
        };
    </script>
</CourseExam>
