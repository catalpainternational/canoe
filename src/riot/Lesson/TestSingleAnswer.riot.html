<TestSingleAnswer>
    <ol>
        <li
            each="{answer in props.card.answers}"
            class="radio {doAnswersMatch(answer, state.selectedAnswer) && howToStyleThe(answer)}"
            onclick="{() => selectAnswer(answer)}"
        >
            <p>{answer.text}</p>
        </li>
    </ol>

    <button
        if="{!props.isCourseExam}"
        class="btn-primary"
        onclick="{showResults}"
        disabled="{state.selectedAnswer === {}}"
    >
        { TRANSLATIONS.checkAnswer() }
    </button>

    <script>
        import { dispatchTestAnswerEvent } from "js/Events";

        export default {
            state: {
                selectedAnswer: {},
                haveCheckedAnswers: false,
                oldProps: undefined,
                newProps: undefined,
            },

            TRANSLATIONS: {
                checkAnswer: () => gettext("Check answer"),
            },

            onMounted(props, state) {
                this.state.newProps = props;
                this.restoreSavedAnswer();
            },

            onUpdated(props, state) {
                // there's no easy/obvious way to observe specific prop changes
                // in riot, so this is a hacky (but working!) way to check if
                // the card id has been changed in order to restore saved answers
                this.state.oldProps = this.state.newProps;
                this.state.newProps = props;
                if (this.state.oldProps && this.state.oldProps.card.id !== this.state.newProps.card.id) {
                    this.restoreSavedAnswer();
                }
            },

            restoreSavedAnswer() {
                const { savedAnswers, card } = this.props;
                if (!savedAnswers.length) {
                    return;
                }

                const answerIndex = savedAnswers.findIndex(it => it.questionId === card.id);
                if (answerIndex > -1) {
                    this.state.selectedAnswer = savedAnswers[answerIndex].answer;
                    this.props.updateAnswerHandler(savedAnswers[answerIndex].answer);
                }
            },

            doAnswersMatch(left, right) {
                return left.text === right.text;
            },

            howToStyleThe(answer) {
                if (this.props.isCourseExam) {
                    return "selected-pending";
                }

                if (this.state.haveCheckedAnswers) {
                    if (!answer.correct) {
                        return "selected-wrong";
                    } else {
                        return "selected";
                    }
                } else {
                    return "selected-pending";
                }

            },

            selectAnswer(answer) {
                this.update({ selectedAnswer: answer, haveCheckedAnswers: false });

                const eventData = {
                    lesson: this.props.lessonName,
                    question: this.props.card.question,
                    answer: answer.text,
                    isAnswerCorrect: answer.correct,
                };
                dispatchTestAnswerEvent(eventData);

                const { isCourseExam } = this.props;
                if (isCourseExam) {
                    const isCorrect = this.gradeAnswer(answer);
                    this.props.recordAnswer({ isCorrect, answers: [answer] });

                    this.props.saveAnswerHandler(this.props.card.id, this.props.card.type, answer);

                    // To avoid update bugs, you must reset the answer between
                    // answer selections.
                    this.state.selectedAnswer = {};
                }
            },

            showResults() {
                this.props.toggleModal(true, this.state.selectedAnswer, this.state.selectedAnswer.correct)
                this.state.haveCheckedAnswers = true;

                if (this.state.selectedAnswer.correct) {
                    this.state.selectedAnswer = {};
                }
            },

            gradeAnswer(answer) {
                return answer.correct;
            },
        };
    </script>
</TestSingleAnswer>
