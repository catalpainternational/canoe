<TestSingleAnswer class="answer">
    <ol>
        <li
            each="{answer in props.card.answers}"
            class="{doAnswersMatch(answer, state.selectedAnswer) && howToStyleThe(answer)}"
            onclick="{() => selectAnswer(answer)}"
        >
            <div>
                <div class="radio">
                    <div></div>
                </div>
                <p>{answer.text}</p>
            </div>
        </li>
    </ol>

    <script>
        import { dispatchTestAnswerEvent } from "@/Events";

        export default {
            state: {
                selectedAnswer: {},
            },

            onMounted(props, state) {
                this.restoreSavedAnswer();
            },

            onUpdated(props, state) {
                if (Object.keys(state.selectedAnswer).length === 0) {
                    this.restoreSavedAnswer();
                } else {
                    this.handleRiotMemoryLeaks();
                }
            },

            restoreSavedAnswer() {
                const { savedAnswer } = this.props;
                if (!savedAnswer) {
                    return;
                }

                this.update({
                    selectedAnswer: savedAnswer[0],
                });
            },

            handleRiotMemoryLeaks() {
                // This method fixes a riot bug(?) that occurs when two
                // TestSingleAnswers are back to back. If question one
                // has a selected answer that matches an answer in question two,
                // question two will automatically select that answer. We don't
                // want that, so this method clears the selected answer between
                // questions.
                this.state.selectedAnswer = {};
            },

            doAnswersMatch(left, right) {
                return left.text === right.text;
            },

            howToStyleThe(answer) {
                if (this.props.isCourseExam) {
                    return "selected-pending";
                } else if (!answer.correct) {
                    return "selected-wrong";
                } else {
                    return "selected";
                }
            },

            selectAnswer(answer) {
                this.update({ selectedAnswer: answer });
                const eventData = {
                    lesson: this.props.lessonName,
                    question: this.props.card.question,
                    answer: answer.text,
                    isAnswerCorrect: answer.correct,
                };
                dispatchTestAnswerEvent(eventData);

                const { isCourseExam } = this.props;
                if (isCourseExam) {
                    const isCorrect = this.gradeAnswer(answer);
                    this.props.recordAnswer({ isCorrect, answers: [answer] });
                } else {
                    this.props.toggleModal(true, answer, answer.correct);
                }
            },

            gradeAnswer(answer) {
                return answer.correct;
            },
        };
    </script>
</TestSingleAnswer>
