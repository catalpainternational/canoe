<VideoCard>
    <div>
        <video
            if="{ !state.src }"
            src="{ state.src }"
            width="100%"
            crossorigin="anonymous"
            controls="true"
            preload="auto"
            onplay="{ (event) => storeAnalytics(event) }"
        >
            <!-- if preload set to none the video will not actually be requested, if set to auto it is requested -->
            <span>{ TRANSLATIONS.browserSupport() }</span>
        </video>
        <p class="error-message" if="{ !state.src }">
            { TRANSLATIONS.missing() }
        </p>
        <h3 class="media-title">{props.media.title}</h3>
        <p class="media-description">{props.media.description}</p>
        <p if={state.cached}>{ TRANSLATIONS.cached() }</p>
        <p if={!state.cached}>{ TRANSLATIONS.notCached() }</p>
    </div>

    <script>
        import { getRoute } from "ReduxImpl/Interface";
        import { getMediaUrl } from "js/RenditionSelector";
        import {
            isItemCached,
            addToCache,
            deleteItemFromCache
        } from "js/cacheManager/cacheManager";
        import { logClickedPlayOnVideo } from "js/GoogleAnalytics";

        export default {
            state: {
                cached: false
            },

            TRANSLATIONS: {
                browserSupport: () => gettext("Your browser does not support the video element."),
                cached: () => gettext("This video will play offline."),
                notCached: () => gettext("This video is not available offline."),
                missing: () => gettext("Sorry: This video is missing.")
            },

            onBeforeMount(props, state) {
                this.page = getRoute().page;
                const asset = this.page.PETEgetMediaRenditions(
                    props.media.id
                );
                const renditions = Object.values(!!asset ? asset.renditions || {} : {});
                let src = "";
                if (renditions.length) {
                    // Choose smallest media item. Much more elaborate strategies are possible, but they need coordination with the backend 
                    // (through TranscodeDefinition objects) to establish a convention on label use. For instance, for audio, the bitrate
                    // (32/64/128kbit ?) could be encoded into the label, and so could the codec (opus/ogg ?).
                    src = getMediaUrl(renditions.sort((el1,el2) => el1.size - el2.size)[0].mediapath);
                }
                this.state.src = src;
                if (src) {
                    isItemCached(src).then(cached => {
                        this.update({cached});
                    });
                }
            },

            storeAnalytics() {
                const mediaTitle = this.props.media.title;
                logClickedPlayOnVideo(mediaTitle);
            },

        };
    </script>
</VideoCard>
