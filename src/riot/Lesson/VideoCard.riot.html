<VideoCard>
    <div>
        <div class="film"></div>
        <video id="thevideo"
            width="100%"
            crossorigin="anonymous"
            controls="true"
            preload="auto"
            onplay="{ (event) => storeAnalytics(event) }"
        >
            <!-- if preload set to none the video will not actually be requested, if set to auto it is requested -->
            <span>{ TRANSLATIONS.browserSupport() }</span>
        </video>
        <h3 class="media-title">{props.media.title}</h3>
        <p class="media-description">{props.media.description}</p>
        <p if={state.cached}>{ TRANSLATIONS.cached() }</p>
        <p if={!state.cached}>{ TRANSLATIONS.notCached() }</p>
    </div>

    <script>
        import { getMediaUrl } from "js/utilities";
        import {
            isItemCached,
            addToCache,
            deleteItemFromCache
        } from "js/cacheManager/cacheManager.js";
        import { getOrFetchManifest } from "js/WagtailPagesAPI";
        import { logClickedPlayOnVideo } from "js/GoogleAnalytics";

        export default {
            state: {
                cached: false
            },

            TRANSLATIONS: {
                browserSupport: () => gettext('Your browser does not support the video element.'),
                cached: () => gettext('This video will play offline.'),
                notCached: () => gettext('This video is not available offline.'),
            },

            async onMounted(props, state) {
                await this.getCacheInfo();
                if (!this.state.cached) {
                    this.toggleAvailableOffline();
                }
                document.getElementById("thevideo").src = await this.getVideoMediaUrl(props.media.source);
            },

            getVideoMediaUrl(videoID) {
                return getOrFetchManifest()
                    // choose smallest video. Much more elaborate strategies are possible, but they need coordination with the backend (through TranscodeDefinition objects) to establish a convention on label use (S/M/L ? 360p/480p/720p ? what about codecs - h264/vp8 ?)
                    .then(mfest => getMediaUrl(Object.values(mfest.media[videoID]).sort((el1,el2) => el1.size - el2.size)[0].mediapath));
            },

            storeAnalytics() {
                const mediaTitle = this.props.media.title;
                logClickedPlayOnVideo(mediaTitle);
            },

            async getCacheInfo() {
                const url = await this.getVideoMediaUrl(this.props.media.source);
                const cached = await isItemCached(url);
                this.update({ cached });
            },

            async toggleAvailableOffline(e) {
                const url = await this.getVideoMediaUrl(this.props.media.source);
                const action = this.state.cached
                    ? deleteItemFromCache(url, "media-cache")
                    : addToCache(url, "media-cache");
                await action;
                this.getCacheInfo();
            },
        };
    </script>
</VideoCard>
