<TestMultipleAnswer>
    <div class="answers-block">
        <h4><raw html="{ TRANSLATIONS.checkAllAnswers() }"></raw></h4>
        <ol>
            <li each="{(answer, index) in props.card.answers}" onclick="{() => selectAnswer(answer)}">
                <div class="checkbox-container {answerClass(answer)}">
                    <div class="checkbox">
                        <span>{state.alphabet[index]}</span>
                    </div>
                    <p class="label">{answer.text}</p>
                </div>
            </li>
        </ol>
    </div>
    <h4 if="{state.visibleAnswers.length > 0}">{ TRANSLATIONS.checkCorrect() }</h4>
    <button
        if="{!props.isCourseExam}"
        class="btn-primary"
        onclick="{showResults}"
        disabled="{state.hiddenAnswers.size === 0 && state.visibleAnswers.size === 0}"
    >
        { TRANSLATIONS.checkAnswers() }
    </button>

    <script>
        import { dispatchTestAnswerEvent } from "js/Events";
        import { doesTheArrayContainTheObject } from "js/utilities";
        import Raw from "RiotTags/Components/Raw.riot.html";

        const doAnswersMatch = (left, right) => {
            return left.text === right.text;
        };

        export default {
            state: {
                hiddenAnswers: [],
                visibleAnswers: [],
                numberTotalCorrectAnswers: 0,
                alphabet: ['A','B','C','D','E','F','G','H','I','J','K','L','M','N',
                    'O','P','Q','R','S','T','U','V','W','X','Y','Z'],
                oldProps: undefined,
                newProps: undefined,
            },

            TRANSLATIONS: {
                checkAllAnswers: () => gettext("Check <strong>all</strong> answers that apply"),
                checkCorrect: () =>
                    gettext("Find and check all correct answers and uncheck incorrect answers"),
                checkAnswers: () => gettext("Check answers"),
            },

            components: {
                raw: Raw,
            },

            onMounted(props, state) {
                const { card } = props;
                const numberTotalCorrectAnswers = card.answers.filter(a => a.correct).length;
                this.update({ numberTotalCorrectAnswers });

                this.restoreSavedAnswer();
            },

            onUpdated(props, state) {
                // there's no easy/obvious way to observe specific prop changes
                // in riot, so this is a hacky (but working!) way to check if
                // the card id has been changed in order to restore saved answers
                this.state.oldProps = this.state.newProps;
                this.state.newProps = props;
                if (this.state.oldProps && this.state.oldProps.card.id !== this.state.newProps.card.id) {
                    this.restoreSavedAnswer();
                }
            },

            restoreSavedAnswer() {
                const { savedAnswers, card } = this.props;

                if (!savedAnswers.length) {
                    return;
                }

                const answerIndex = savedAnswers.findIndex(it => it.questionId === card.id);
                if (answerIndex > -1) {
                    this.state.hiddenAnswers = savedAnswers[answerIndex].answers;

                    const isCorrect = this.gradeAnswers(this.state.hiddenAnswers);
                    this.props.updateAnswerHandler(savedAnswers[answerIndex].answers, isCorrect);
                }
            },

            doesArrayIncludeAnswer(answersArray, answerToCheck) {
                return doesTheArrayContainTheObject(answersArray, answerToCheck, doAnswersMatch);
            },

            showResults() {
                let { visibleAnswers, hiddenAnswers } = this.state;

                visibleAnswers = [...visibleAnswers, ...hiddenAnswers];
                hiddenAnswers = [];
                this.update({ visibleAnswers, hiddenAnswers });

                const isQuestionComplete = this.gradeAnswers(visibleAnswers);
                this.props.toggleModal(true, {}, isQuestionComplete);

                if (isQuestionComplete) {
                    this.update({
                        visibleAnswers: [],
                        hiddenAnswers: [],
                    });
                }
            },

            answerClass(answer) {
                if (this.doesArrayIncludeAnswer(this.state.visibleAnswers, answer)
                    && answer.correct) return "answer-success";
                if (this.doesArrayIncludeAnswer(this.state.visibleAnswers, answer)
                    && !answer.correct) return "answer-warning";
                if (this.doesArrayIncludeAnswer(this.state.hiddenAnswers, answer)
                    && !this.doesArrayIncludeAnswer(this.state.visibleAnswers, answer)) return "answer-pending";
            },

            selectAnswer(answer) {
                this.addSelectionToAnswers(answer);

                const { isCourseExam } = this.props;
                if (isCourseExam) {
                    this.reportAnswersToExam();
                    this.props.saveAnswerHandler(
                        this.props.card.id,
                        this.props.card.type,
                        this.state.hiddenAnswers
                    );
                }
            },

            addSelectionToAnswers(answer) {
                let { visibleAnswers, hiddenAnswers } = this.state;

                if (this.doesArrayIncludeAnswer(visibleAnswers, answer)) {
                    visibleAnswers = visibleAnswers.filter(
                        visible => !doAnswersMatch(visible, answer)
                    );
                } else if (this.doesArrayIncludeAnswer(hiddenAnswers, answer)) {
                    hiddenAnswers = hiddenAnswers.filter(hidden => !doAnswersMatch(hidden, answer));
                } else {
                    hiddenAnswers.push(answer);
                }

                this.update({ visibleAnswers, hiddenAnswers });
            },

            reportAnswersToExam() {
                const { visibleAnswers, hiddenAnswers } = this.state;
                const answers = [...visibleAnswers, ...hiddenAnswers];
                const isCorrect = this.gradeAnswers(answers);
                this.props.recordAnswer({ isCorrect, answers });
            },

            gradeAnswers(answers) {
                console.assert(Array.isArray(answers), `"answers" must come in as an Array`);

                const numberIncorrectAnswersChosen = answers.filter(a => !a.correct).length;
                const numberCorrectAnswersChosen = answers.filter(a => a.correct).length;

                const isQuestionComplete =
                    numberCorrectAnswersChosen === this.state.numberTotalCorrectAnswers &&
                    numberIncorrectAnswersChosen === 0;
                return isQuestionComplete;
            },
        };
    </script>
</TestMultipleAnswer>
